[ { "title": "프린터큐", "url": "/posts/%ED%94%84%EB%A6%B0%ED%84%B0-%ED%81%90/", "categories": "코테", "tags": "getting started", "date": "2022-08-28 21:55:00 +0900", "snippet": "문제여러분도 알다시피 여러분의 프린터 기기는 여러분이 인쇄하고자 하는 문서를 인쇄 명령을 받은 ‘순서대로’, 즉 먼저 요청된 것을 먼저 인쇄한다. 여러 개의 문서가 쌓인다면 Queue 자료구조에 쌓여서 FIFO - First In First Out - 에 따라 인쇄가 되게 된다. 하지만 상근이는 새로운 프린터기 내부 소프트웨어를 개발하였는데, 이 프린터기는 다음과 같은 조건에 따라 인쇄를 하게 된다.현재 Queue의 가장 앞에 있는 문서의 ‘중요도’를 확인한다.나머지 문서들 중 현재 문서보다 중요도가 높은 문서가 하나라도 있다면, 이 문서를 인쇄하지 않고 Queue의 가장 뒤에 재배치 한다. 그렇지 않다면 바로 인쇄를 한다.예를 들어 Queue에 4개의 문서(A B C D)가 있고, 중요도가 2 1 4 3 라면 C를 인쇄하고, 다음으로 D를 인쇄하고 A, B를 인쇄하게 된다.여러분이 할 일은, 현재 Queue에 있는 문서의 수와 중요도가 주어졌을 때, 어떤 한 문서가 몇 번째로 인쇄되는지 알아내는 것이다. 예를 들어 위의 예에서 C문서는 1번째로, A문서는 3번째로 인쇄되게 된다.입력첫 줄에 테스트케이스의 수가 주어진다. 각 테스트케이스는 두 줄로 이루어져 있다.테스트케이스의 첫 번째 줄에는 문서의 개수 N(1 ≤ N ≤ 100)과, 몇 번째로 인쇄되었는지 궁금한 문서가 현재 Queue에서 몇 번째에 놓여 있는지를 나타내는 정수 M(0 ≤ M &lt; N)이 주어진다. 이때 맨 왼쪽은 0번째라고 하자. 두 번째 줄에는 N개 문서의 중요도가 차례대로 주어진다. 중요도는 1 이상 9 이하의 정수이고, 중요도가 같은 문서가 여러 개 있을 수도 있다.출력각 테스트 케이스에 대해 문서가 몇 번째로 인쇄되는지 출력한다.풀이리스트에서 최대값 제거하면서 출력 순서 찾으니까 중요도가 동일한게 있는 경우 해결이 안됨참고stack.pop(-1) 제거안하고 마지막 요소 출력stack.pop() 마지막 요소 제거내가 푼 풀이N = int(input())for _ in range(N): n,m = map(int,input().split()) list1 = list(map(int,input().split()))# n 페이지 수# m번째로 출력되는 요소 궁금 printNum = list1[m] rsltCnt = 0 maxNum = 0 for i in range(1,len(list1)+1): maxNum = max(list1) list1.remove(max(list1)) if maxNum == printNum: rsltCnt=i print(rsltCnt)참고한 풀이from collections import dequeimport syst = int(input())for i in range(t): n, m = map(int, input().split()) queue = deque(list(map(int, sys.stdin.readline().split()))) count = 0 while queue: best = max(queue) #현재의 최댓값이 가장 먼저 배출되므로 최댓값을 저장 front = queue.popleft() # 큐의 front를 뽑았으므로 m -= 1 # 내 위치가 한 칸 당겨진다. if best == front: # 뽑은 숫자가 제일 큰 숫자일 때 count += 1 # 하나가 영원히 배출되므로 순번 하나 추가 if m &lt; 0: # m이 0이라는 것은 뽑은 숫자가 내 숫자라는 뜻. print(count) break else: # 뽑은 숫자가 제일 큰 숫자가 아니면 queue.append(front) # 제일 뒤로 밀려나게 됨 if m &lt; 0 : # 제일 앞에서 뽑히면 m = len(queue) - 1 # 제일 뒤로 이동" }, { "title": "좋은 단어", "url": "/posts/%EC%A2%8B%EC%9D%80-%EB%8B%A8%EC%96%B4/", "categories": "코테", "tags": "getting started", "date": "2022-08-28 21:55:00 +0900", "snippet": "문제이번 계절학기에 심리학 개론을 수강 중인 평석이는 오늘 자정까지 보고서를 제출해야 한다. 보고서 작성이 너무 지루했던 평석이는 노트북에 엎드려서 꾸벅꾸벅 졸다가 제출 마감 1시간 전에 깨고 말았다. 안타깝게도 자는 동안 키보드가 잘못 눌려서 보고서의 모든 글자가 A와 B로 바뀌어 버렸다! 그래서 평석이는 보고서 작성을 때려치우고 보고서에서 ‘좋은 단어’나 세보기로 마음 먹었다.평석이는 단어 위로 아치형 곡선을 그어 같은 글자끼리(A는 A끼리, B는 B끼리) 쌍을 짓기로 하였다. 만약 선끼리 교차하지 않으면서 각 글자를 정확히 한 개의 다른 위치에 있는 같은 글자와 짝 지을수 있다면, 그 단어는 ‘좋은 단어’이다. 평석이가 ‘좋은 단어’ 개수를 세는 것을 도와주자.입력첫째 줄에 단어의 수 N이 주어진다. (1 ≤ N ≤ 100)다음 N개 줄에는 A와 B로만 이루어진 단어가 한 줄에 하나씩 주어진다. 단어의 길이는 2와 100,000사이이며, 모든 단어 길이의 합은 1,000,000을 넘지 않는다.출력첫째 줄에 좋은 단어의 수를 출력한다.풀이어렵다내가 푼 풀이import sysinput = sys.stdin.readlinen = int(input())cnt = 0for _ in range(n): s = input().rstrip() stack = [] for i in range(len(s)): if stack and s[i] == stack[-1]: // 스택 비어있지않거나 맨마지막값확인 stack.pop() else: stack.append(s[i]) if not stack: cnt += 1print(cnt)" }, { "title": "강의실 문제", "url": "/posts/%EA%B0%95%EC%9D%98%EC%8B%A4-%EB%B0%B0%EC%A0%95%EB%AC%B8%EC%A0%9C/", "categories": "코테", "tags": "그리디", "date": "2022-08-21 20:26:00 +0900", "snippet": "문제수강신청의 마스터 김종혜 선생님에게 새로운 과제가 주어졌다.김종혜 선생님한테는 Si에 시작해서 Ti에 끝나는 N개의 수업이 주어지는데, 최소의 강의실을 사용해서 모든 수업을 가능하게 해야 한다.참고로, 수업이 끝난 직후에 다음 수업을 시작할 수 있다. (즉, Ti ≤ Sj 일 경우 i 수업과 j 수업은 같이 들을 수 있다.)수강신청 대충한 게 찔리면, 선생님을 도와드리자!입력첫 번째 줄에 N이 주어진다. (1 ≤ N ≤ 200,000)이후 N개의 줄에 Si, Ti가 주어진다. (0 ≤ Si &lt; Ti ≤ 109)출력강의실의 개수를 출력하라.풀이끝나는 시간과 다음 시작하는 시간을 비교하여 방의 수를 추가함내가 푼 풀이import heapqN = int(input())result =[]for i in range(N): result.append(list(map(int,input().split())))result.sort()room = []heapq.heappush(room,result[0][1])for i in range(1, N): if result[i][0] &lt; room[0]: # 현재 회의실 끝나는 시간보다 다음 회의 시작시간이 빠르면 heapq.heappush(room, result[i][1]) # 새로운 회의실 개설 else: # 현재 회의실에 이어서 회의 개최 가능 heapq.heappop(room) # 새로운 회의로 시간 변경을 위해 pop후 새 시간 push heapq.heappush(room, result[i][1])print(len(room))" }, { "title": "신입사원 문제", "url": "/posts/%EC%8B%A0%EC%9E%85%EC%82%AC%EC%9B%90%EB%AC%B8%EC%A0%9C/", "categories": "코테", "tags": "그리디", "date": "2022-08-21 19:18:00 +0900", "snippet": "문제언제나 최고만을 지향하는 굴지의 대기업 진영 주식회사가 신규 사원 채용을 실시한다. 인재 선발 시험은 1차 서류심사와 2차 면접시험으로 이루어진다. 최고만을 지향한다는 기업의 이념에 따라 그들은 최고의 인재들만을 사원으로 선발하고 싶어 한다.그래서 진영 주식회사는, 다른 모든 지원자와 비교했을 때 서류심사 성적과 면접시험 성적 중 적어도 하나가 다른 지원자보다 떨어지지 않는 자만 선발한다는 원칙을 세웠다. 즉, 어떤 지원자 A의 성적이 다른 어떤 지원자 B의 성적에 비해 서류 심사 결과와 면접 성적이 모두 떨어진다면 A는 결코 선발되지 않는다.이러한 조건을 만족시키면서, 진영 주식회사가 이번 신규 사원 채용에서 선발할 수 있는 신입사원의 최대 인원수를 구하는 프로그램을 작성하시오.입력첫째 줄에는 테스트 케이스의 개수 T(1 ≤ T ≤ 20)가 주어진다. 각 테스트 케이스의 첫째 줄에 지원자의 숫자 N(1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N개 줄에는 각각의 지원자의 서류심사 성적, 면접 성적의 순위가 공백을 사이에 두고 한 줄에 주어진다. 두 성적 순위는 모두 1위부터 N위까지 동석차 없이 결정된다고 가정한다.출력각 테스트 케이스에 대해서 진영 주식회사가 선발할 수 있는 신입사원의 최대 인원수를 한 줄에 하나씩 출력한다.풀이이중 for문으로 인해 시간복잡도가 증가하여 시간초과가 나고있음.추후 수정함.내가 푼 풀이N = int(input())for i in range(N): C = int(input()) result = [] person = 0 for i in range(C): result.append(list(map(int,input().split()))) for i in range(len(result)-1): if result[i][0] &lt; result[i+1][0] or result[i][1] &lt; result[i+1][1]: person += 1 print(person)남이 푼 풀이import sysinput = sys.stdin.readlineT = int(input())for _ in range(T): N = int(input()) rank = [list(map(int, input().split())) for _ in range(N)] rank_asc = sorted(rank) top = 0 result = 1 for i in range(1, len(rank_asc)): if rank_asc[i][1] &lt; rank_asc[top][1]: top = i result += 1 print(result)" }, { "title": "괄호 문제", "url": "/posts/%EA%B4%84%ED%98%B8%EB%AC%B8%EC%A0%9C/", "categories": "코테", "tags": "그리디", "date": "2022-08-21 19:18:00 +0900", "snippet": "문제세준이는 양수와 +, -, 그리고 괄호를 가지고 식을 만들었다. 그리고 나서 세준이는 괄호를 모두 지웠다.그리고 나서 세준이는 괄호를 적절히 쳐서 이 식의 값을 최소로 만들려고 한다.괄호를 적절히 쳐서 이 식의 값을 최소로 만드는 프로그램을 작성하시오.입력첫째 줄에 식이 주어진다. 식은 ‘0’~‘9’, ‘+’, 그리고 ‘-’만으로 이루어져 있고, 가장 처음과 마지막 문자는 숫자이다. 그리고 연속해서 두 개 이상의 연산자가 나타나지 않고, 5자리보다 많이 연속되는 숫자는 없다. 수는 0으로 시작할 수 있다. 입력으로 주어지는 식의 길이는 50보다 작거나 같다.출력첫째 줄에 정답을 출력한다.풀이내가 푼 풀이array = input().split('-')result=0for i in range(len(array)): if i==0: result += sum(map(int,array[i].split('+'))) else: result -= sum(map(int,array[i].split('+')))print(result)" }, { "title": "sts(spring tool suite)", "url": "/posts/sts/", "categories": "개념", "tags": "sts", "date": "2022-08-08 22:01:00 +0900", "snippet": "stsSpring Framework를 이용한 프로젝트를 진행하다 보면 이클립스와 sts를 많이 사용하게 된다.STS(Spring tool suite)는 스프링 개발에 최적화된 이클립스라고 생각하면 된다.이클립스 베이스에 Spring Framework plugin이 자동으로 추가된 버전이다.기존 이클립스에 STS plug-in 별도 추가 설치STS(Spring Tool Suite) 바로 개발 가능장점으로는 이클립스는 톰캣을 직접 설치하고 따로 실행줘야 하는데STS는 개발자용 톰캣서버도 같이 설치 및 실행해주는 편리함이 있다.스프링부트스프링 프레임워크는 기능이 많은 만큼 환경설정이 복잡한 편이다.그래서 환경설정을 편하게 만들어서 나온게 스프링 부트이다.스프링부트는 스프링 프레임워크를 사용하기 위한 설정의 많은 부분을 자동화 하여 사용자가 정멸 편하게 스프링을 활용하게 돕는다스프링 부트 starter 디펜던시만 추가해주면 바로 API를 정의하고, 내장된 톰캣이나 제티로 웹 애플리케이션 서버를 실행할 수 있다.심지어 스프링 홈페이지의 이니셜라이저를 사용하면 바로 실행가능한 코드를 만들어준다.실행환경이나 의존성 관리 등의 인프라 관련 등은 신경쓸 필요 없이 바로 코딩을 시작하면 된다.그리고 바로 그것이 스프링의 키 포인트이다.스프링 프레임워크프레임 워크중 가장 많이 사용되고 있고 자바 웹 애플리케이션 개발을 위한 오픈소스 프레임워크로 기존 프레임워크보다 가벼운 경량 프레임워크이다.또한 스프링은 경량 컨테이너라고 부른다. ‘컨테이너’라고 하면 대표적인 것으로 톰캣을 들 수 있다. 톰캣은 서블릿 컨테이너라고 부르는데, 그이유는 콤캣을 실행하면 톰캣은 서블릿의 생성,초기화,서비스실행, 소멸에 관한 모든 권한을 가지고 서블릿을 관리하기 때문이다.그리고 애플리케이션에서 사용되는 여러가지 빈(클래스 객체)을 개발자가 아닌 스프링이 권한을 가지고 직접 관리한다.스프링은 JAVA기술을 더 쉽게 사용할 수 있게 해주는 오픈소스 프레임워크이다.그래서 STS가 아니라 이클립ㅂ스에서 스프링을 적용해서 개발할 수도 있고(STS 보다 설정을 더 직접 잡아야 한다)아니면 스프링으로 개발하는 것에 특화된 STS로 개발할 수 도 있다.스프링의 주요 특징으로 4가지가 있는데 한번 훑어본다. IoC(Inversion of Control, 제어반전) 개발자는 JAVA코딩시 new 연산자, 인터페이스 호출, 데이터 클래스 호출 방식으로 객체를 생성하고 소멸시킨다. loC란 인스턴스(객체)의 생성부터 소멸까지 객체 생명주기 관리를 개발자가 하는게 아닌 스피링(컨테이너)가 대신 해주는 것을 말한다. 프로젝트의 규모가 커질수록 객체와 자원을 이용하는 방법이 더 복잡해지고 어디서 코드가 꼬일지 모르는 것을 Spring의 IoC는 자동으로 관리해준다. 즉, 제어권이 개발자가 아닌 IoC에게 있으며 IoC가 개발자의 코드를 호출하여 그 코드로 생명주기를 제어하는 것이다. DI(Dependency Injection, 의존성 주입) 프로그래밍에서 구성요소 간의 의존 관계가 소스코드 내부가 아닌 외부의 설정파일을 통해 정의되는 방식이다. 코드 재사용을 높여 재사용을 높여 소스코드를 다양한 곳에 사용할 수 있으며 모듈간의 결합도도 낮출 수 있다. 쉽게 말하자면 게임 캐릭터라는 하나의 객체가 존재하는데, 그 객체를 더 잘 이용하기 위해서 무기, 방패 등 아이템을 가져와 결합시키는 것이다. 이 객체는 무기와 방패를 뺐다 꼈다 자유자재로 할 수 있으며 아이템을 갈아끼우는데 어떤 상황에 구애받지도 않는다. JAVA에서 데이터를 저장하고 가져오는 기능을 외부의 Oracle Database를 사용할 수도 있고, JDBC, iBatis, JPA 등 다른 프레임 워크를 이용해 짤 수도 있다. 이때 Spring을 이용하면 그때마다 필요한 부분을 뺐다 꼈다 하면서 적절한 상황에 필요한 기능을 해낼 수 있다. AOP(Aspect Object Programming, 관점 지향 프로그래밍) 로깅, 트랜잭션, 보안 등 여러 모듈에서 공통적으로 사용하는 기능을 분리하여 관리 할 수 있다. 각각의 클래스가 있다고 가정하자. 각 클래스들은 서로 코드와 기능들이 중복되는 부분이 많다. 코드가 중복될 경우 실용성과 가독성 및 개발 속도에 좋지 않다. 중복된 코드를 최대한 배제하는 방법은 중복되는 기능들을 전부 빼놓은 뒤 그 기능이 필요할때만 호출하여 쓰면 훨씬 효율성이 좋다. 즉, AOP는 여러 객체에 공통으로 적용할 수 있는 기능을 구분함으로써 재사용성을 높여주는 프로그래밍 기법이다. POJO(Plain Old Java Object) 방식 POJO는 Java EE를 사용하면서 해당 플랫폼에 종속되어 있는 무거운 객체들을 만드는 것에 반발하여 나타난 용어이다. 별도의 프레임 워크 없이 Java EE를 사용할 때에 비해 인터페이스를 직접 구현하거나 상속받을 필요가 없어 기존 라이브러리를 지원하기 용이하고, 객체가 가볍다. 즉, getter/setter를 가진 단순한 자바 오브젝트를 말한다. " }, { "title": "디자인 시스템 개념", "url": "/posts/%EB%94%94%EC%9E%90%EC%9D%B8%EC%8B%9C%EC%8A%A4%ED%85%9C/", "categories": "디자인시스템", "tags": "", "date": "2022-07-27 21:55:00 +0900", "snippet": "디자인 가이드에는 여러 종류가 있다. 간단히 살펴보면 3가지 정도로 나눌 수 있다.UI 가이드라인 (스타일 가이드)UI를 표준화하고 화면 간의 일관성을 확보하기 위한 가이드.주요 화면에서 사용되는 공통 UI 패턴과 주요 컴포넌트를 추출해 정의하고 상세 속성을 규정하여 디자이너와 개발자가 정해진 기준에 따라 UI를 설계할 수 있게 한다.UX 가이드라인서비스와 브랜드 측면에서 사용자가 일관적이고 차별화된 경험을 하도록 하기 위한 가이드.사용자 콘텍스트를 재구성하여 사용자 입장에서 서비스를 설계하도록 가이드라인을 구성한다. 브랜드 측면에서는 해당 브랜드의 정체성이나 색을 일관되게 전달하도록 하는 기능 정의, 네이밍, 어투, GUI적 요소를 정의한다.디자인 시스템디자인 원칙과 규격, 재사용 가능한 UI 패턴과 컴포넌트, 코드를 포괄하는 시스템.단순 스타일 가이드, 패턴 라이브러리 역할만 하는 디자인 시스템도 있고, 브랜드 원칙과 UX 원칙에 이르는 하나의 철학을 구성하는 시스템도 있다.정해진 디자인 패턴과 컴포넌트를 재사용하여 제품을 구축하고 개선하는 시간을 단축시켜준다. 일종의 레고 세트라고 볼 수 있다.디자인 시스템은 조직에 많은 이점을 가져다준다. 여러 디자이너가 프로젝트에 참여하고 있는 경우에도 모든 제품의 인터페이스가 일관성을 유지할 수 있도록 도와준다. UI를 다시 만들거나 옛날 디자인 파일을 찾아 헤매지 않고 더 중요한 문제를 해결하는 데 집중할 수 있다.디자인 시스템의 필요성1) 플랫폼 특성상 반복적으로 사용되는 컴포넌트, 페이지를 디자이너마다 매번 새로 다시 제작함.2) 디자인 팀 내부에서 공유된 재사용 컴포넌트는 정해진 가이드라인이 없어 디자이너마다 아웃풋이 조금씩 다르게 완성됨. 결국 재사용과 관계없이 개발자는 매번 새로 컴포넌트를 개발해야 했음.3) 웹앱 특성상 반응형에 대응해야 하는데, 반복되는 레이아웃의 경우에도 구체적인 디자인이 없으면 개발자가 임의대로 반응형 화면을 작업할 수 없었기 때문에 일일이 디자이너가 작업해 전달해야 했음. 이과정에서 비효율적인 시간이 소모됨.4) 비교적 우선순위가 낮은 페이지(공지사항, 설정 등)에 소모되는 시간에, 제품 전반의 사용자 경험에 더 집중하고 디벨롭하고 싶음." }, { "title": "ARIA 블록 알고리즘 암호화 복호화", "url": "/posts/aria/", "categories": "암호화", "tags": "aria", "date": "2022-07-27 21:55:00 +0900", "snippet": "개요양방향 암호화 복호화를 해야 하는 경우에 사용하는 알고리즘이다.hash는 단방향 암호화 기법이고 encryption은 양방향 암호화 기법이다.아리아는 대한민국의 국가보안기술연구소에서 개발한 블록 암호 체계이다. ARIA 라는 이름은 학계(Academy), 연구소(research Institute), 정부 기관(Agency)이 공동으로 개발한특징을 함축적으로 표현한 것이다. 대한민국의 국가 표준 암호 알고리즘으로 기능하고 있으며, 2010년 웹 표준 중 하나가 되었다.사용법 1. pom.xml다음항목을 pom.xml에 포함되어 있는지 확인하고 없으면 추가해 준다. 2. globals.propertiesglobals.properties에 설정 값을 추가해 줍니다. #패스워드 인코더에 사용될 hash function 알고리즘 (default : SHA-256)crypto.password.algorithm = SHA-256crypto.plain.password = egovframe #이건 프로그램에 하드코딩 필요crypto.hashed.password=gdyYs/IZqY86VcWhT8emCYfqY1ahw2vtLG+/FzNqtrQ=암호화의 경우 암호화 및 복호화를 위한 키를 지정해야 하고 키 값이 있으면 원문으로 전환이 가능하기 때문에보안상 HASH FUNCTION 사용을 권장한다.crypto.password.algorithm : 패스워드 인코더에 사용될 hash function 알고리즘 (default : SHA-256)crypto.hashed.password : 패스워드에 대한 hash value (egovframework.rte.fdl.cryptography.EgovPasswordEncoder의 main 메소드에 의해 해당 값을 얻어 기록한다.)" }, { "title": "동전 문제", "url": "/posts/%EB%8F%99%EC%A0%84-%EB%AC%B8%EC%A0%9C/", "categories": "코테", "tags": "getting started", "date": "2022-07-25 21:55:00 +0900", "snippet": "문제준규가 가지고 있는 동전은 총 N종류이고, 각각의 동전을 매우 많이 가지고 있다.동전을 적절히 사용해서 그 가치의 합을 K로 만들려고 한다. 이때 필요한 동전 개수의 최솟값을 구하는 프로그램을 작성하시오.입력첫째 줄에 N과 K가 주어진다. (1 ≤ N ≤ 10, 1 ≤ K ≤ 100,000,000)둘째 줄부터 N개의 줄에 동전의 가치 Ai가 오름차순으로 주어진다. (1 ≤ Ai ≤ 1,000,000, A1 = 1, i ≥ 2인 경우에 Ai는 Ai-1의 배수)코딩 테스트 준비 완료출력첫째 줄에 K원을 만드는데 필요한 동전 개수의 최솟값을 출력한다.풀이최솟값을 구하는것이므로 동전 종류를 내림차순으로 정렬하고목표값을 가장 값이 큰 동전으로 먼저 나눠가는 방식을 택했다.내가 푼 풀이N, total = map(int,input().split())count = 0;list = [];for i in range(N): list.append(int(input()))list.sort(reverse=True)for i in list: divide = int(total / i) if(divide) != 0: count += divide total -= (int(divide) *i)print(count)남이 푼 풀이N, value = map(int,input().split())coins = []for i in range(N): coins.append(int(input()))coins.reverse()count = 0#temp = 0#for i in coins:# if(temp == value): # break #count += i // value #temp += i * (i // value)count = 0for i in coins: count += value//i #카운트 값에 K를 동전으로 나눈 몫을 더해줌 value = value%iprint(count)" }, { "title": "UCPC 문제", "url": "/posts/UCPC/", "categories": "코테", "tags": "getting started", "date": "2022-07-25 21:55:00 +0900", "snippet": "문제UCPC는 ‘전국 대학생 프로그래밍 대회 동아리 연합 여름 대회’의 줄임말로 알려져있다. 하지만 이 줄임말이 정확히 어떻게 구성되었는지는 아무도 모른다. UCPC 2018을 준비하던 ntopia는 여러 사람들에게 UCPC가 정확히 무엇의 줄임말인지 물어보았지만, 아무도 정확한 답을 제시해주지 못했다. ntopia가 들은 몇 가지 답을 아래에 적어보았다.Union of Computer Programming Contest club contestUnion of Computer Programming contest Club contestUnion of Computer Programming contest club ContestUnion of Collegiate Programming Contest club contestUnion of Collegiate Programming contest Club contestUnion of Collegiate Programming contest club ContestUniversity Computer Programming ContestUniversity Computer Programming Club contestUniversity Computer Programming club ContestUniversity Collegiate Programming ContestUniversity CPC…ntopia는 이렇게 다양한 답을 듣고는 UCPC가 무엇의 약자인지는 아무도 모른다고 결론내렸다. 적당히 슥삭해서 UCPC를 남길 수 있으면 모두 UCPC의 약자인 것이다!문자열이 주어지면 이 문자열을 적절히 축약해서 “UCPC”로 만들 수 있는지 확인하는 프로그램을 만들어보자.축약이라는 것은 문자열에서 임의의 문자들을 제거하는 행동을 뜻한다. 예를 들면, “apple”에서 a와 e를 지워 “ppl”로 만들 수 있고, “University Computer Programming Contest”에서 공백과 소문자를 모두 지워 “UCPC”로 만들 수 있다.문자열을 비교할 때는 대소문자를 구분해 정확히 비교한다. 예를 들어 “UCPC”와 “UCpC”는 다른 문자열이다. 따라서 “University Computer programming Contest”를 “UCPC”로 축약할 수 있는 방법은 없다.그나저나 UCPC는 정말 무엇의 약자였을까? 정확히 아시는 분은 제보 부탁드립니다.입력첫 번째 줄에 알파벳 대소문자, 공백으로 구성된 문자열이 주어진다. 문자열의 길이는 최대 1,000자이다. 문자열의 맨 앞과 맨 끝에 공백이 있는 경우는 없고, 공백이 연속해서 2번 이상 주어지는 경우도 없다.출력첫 번째 줄에 입력으로 주어진 문자열을 적절히 축약해 “UCPC”로 만들 수 있으면 “I love UCPC”를 출력하고, 만들 수 없으면 “I hate UCPC”를 출력한다.예제입력Union of Computer Programming Contest club contest예제 출력 1I love UCPC풀이내가 푼 풀이왜 틀렸는지 전혀모르겠다.왜 이런문제를 골라왔는지 모르겠다.나의 문제 풀이 방법은 문자열의 공백을 제거하였고, 각 문자를 아스키 코드로 변환하여 대문자만 변수에 담는방식을 택하였다.그러나 왜 틀렸는지 모르겠다.words = input()chgWords = words.replace(' ','')result = \"\"for i in chgWords: #print(i) ascCd = ord(i) if(65&lt;= ascCd &lt;=90): result += i#print(result)if('UCPC' in result): print(\"I love UCPC\")else: print(\"I hate UCPC\")print(count)" }, { "title": "1449번 수리공 항승", "url": "/posts/1449/", "categories": "코테", "tags": "그리디", "date": "2022-07-25 21:55:00 +0900", "snippet": "문제항승이는 품질이 심각하게 나쁜 수도 파이프 회사의 수리공이다. 항승이는 세준 지하철 공사에서 물이 샌다는 소식을 듣고 수리를 하러 갔다.파이프에서 물이 새는 곳은 신기하게도 가장 왼쪽에서 정수만큼 떨어진 거리만 물이 샌다.항승이는 길이가 L인 테이프를 무한개 가지고 있다.항승이는 테이프를 이용해서 물을 막으려고 한다. 항승이는 항상 물을 막을 때, 적어도 그 위치의 좌우 0.5만큼 간격을 줘야 물이 다시는 안 샌다고 생각한다.물이 새는 곳의 위치와, 항승이가 가지고 있는 테이프의 길이 L이 주어졌을 때, 항승이가 필요한 테이프의 최소 개수를 구하는 프로그램을 작성하시오. 테이프를 자를 수 없고, 테이프를 겹쳐서 붙이는 것도 가능하다.입력첫째 줄에 물이 새는 곳의 개수 N과 테이프의 길이 L이 주어진다. 둘째 줄에는 물이 새는 곳의 위치가 주어진다. N과 L은 1,000보다 작거나 같은 자연수이고, 물이 새는 곳의 위치는 1,000보다 작거나 같은 자연수이다.출력첫째 줄에 항승이가 필요한 테이프의 개수를 출력한다.예제입력4 21 2 100 101예제 출력 12풀이내가 푼 풀이첫시도 실패맨 마지막 인덱스에서만 카운트가 된다면 끝이였는데아웃오브인덱스와, 카운트를 하지 못해 실패하였다.그래서 구글의 힘을 받기로 하였다.count = 0for i in range(N): if i == N-1: break; print(length, list1[i+1] - list1[i]) if(length &gt; list1[i+1] - list1[i]): length -= list1[i+1] - list1[i] continue; else: count += 1 length = lengthprint(count)구글의 도움을 받음N,length = map(int,input().split())list1 = list(map(int,input().split()))list1.sort()select = list1[0]i = 1result = 1for i in range(N): if list1[i] &gt;= select + length: result +=1 select = list1[i] i += 1print(result)" } ]
